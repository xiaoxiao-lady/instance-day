then(onFulfilled, onRejected) {
// onFulfilled 如果不是函数，就忽略 onFulfilled，直接返回 value
onFulfilled =
typeof onFulfilled === "function" ? onFulfilled : (value) => value;
onRejected =
typeof onRejected === "function"
? onRejected
: (err) => {
throw err;
};
// 实现链式调用所以需要返回的是一个 promise
let promise2 = new myPromise((resolve, reject) => {
if (this.status === statusOptions["FULFILLED"]) {
// promiseA+规范规定 onFulfilled, onRejected 不能是同步的;
setTimeout(() => {
try {
const x = onFulfilled(this.result); //执行函数，传出去终值
resolvePromise(promise2, x, resolve, reject); //处理 x 的不同值 ,为了将这个 promise2 返回的值传递到下一个 then 中
} catch (error) {
reject(error);
}
}, 0);
} else if (this.status === statusOptions["REJECTED"]) {
setTimeout(() => {
try {
const x = onRejected(this.result); //执行函数，传出去终值
resolvePromise(promise2, x, resolve, reject);
} catch (error) {
reject(error);
}
}, 0);
} else if (this.status === statusOptions["PENDING"]) {
// 实现异步
this.onFulfilledCallbacks.push(() => {
setTimeout(() => {
try {
const x = onFulfilled(this.result); //执行函数，传出去终值
resolvePromise(promise2, x, resolve, reject);
} catch (error) {
reject(error);
}
}, 0);
});
this.onRejectedCallbacks.push(() => {
setTimeout(() => {
try {
const x = onRejected(this.result); //执行函数，传出去终值
resolvePromise(promise2, x, resolve, reject); //处理 x 的不同值
} catch (error) {
reject(error);
}
}, 0);
});
}
});
return promise2;
}

3.1 标记清除

这是 javascript 中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。
当对象，无法从根对象沿着引用遍历到，即不可达（unreachable），进行清除。对于上面的例子，fn() 里面的 a 和 b 在函数执行完毕后，就不能通过外面的上下文进行访问了，所以就可以清除了。
这是当前主流的 GC 算法，V8 里面就是用这种。
不管是高级语言，还是低级语言。内存的管理都是：分配内存使用内存（读或写）释放内存前两步，大家都没有太大异议。关键是释放内存这一步，各种语言都有自己的垃圾回收（garbage collection, 简称 GC）机制。

在大部分的应用场景：一个新创建的对象，生命周期通常很短。所以，V8 里面，GC 处理分为两大类：新生代和老生代。
新生代的堆空间为 1M~8M，而且被平分成两份（to-space 和 from-space），通常一个新创建的对象，内存被分配在新生代。当 to-space 满的时候，to-space 和 form-space 交换位置（此时，to 空，from 满），并执行 GC。如果一个对象被断定为，未被引用，就清除；有被引用，逃逸次数+1（如果此时逃逸次数为 2，就移入老生代，否则移入 to-space）。
老生代的堆空间大，GC 不适合像新生代那样，用平分成两个 space 这种空间换时间的方式。老生代的垃圾回收，分两个阶段：标记、清理（有 Sweeping 和 Compacting 这两种方式）。
标记，采用 3 色标记：黑、白、灰。步骤如下：
GC 开始，所以对象标记为白色。
根对象标记为黑色，并开始遍历其子节点（引用的对象）。
当前被遍历的节点，标记为灰色，被放入一个叫 marking bitmap 的栈。在栈中，把当前被遍历的节点，标记为黑色，并出栈，同时，把它的子节点（如果有的话）标记为灰色，并压入栈。（大对象比较特殊，这里不展开）
当所有对象被遍历完后，就只剩下黑和白。通过 Sweeping 或 Compacting 的方式，清理掉白色，完成 GC。
3.2 引用计次
引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1。当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。
但是用这种方法存在着一个问题，下面来看看代码：
function problem() {
var objA = new Object();
var objB = new Object();

    objA.someOtherObject = objB;
    objB.anotherObject = objA;

}

在这个例子中，objA 和 objB 通过各自的属性相互引用；也就是说这两个对象的引用次数都是 2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA 和 objB 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。
大多数浏览器已经放弃了这种回收方式。

4. 浏览器的本地存储
   如果我问你，浏览器中的缓存有哪些，我相信绝大部分人会说有三种：cookie，sessionStorage，localStorage。
   但是诶，我不知为什么大家都叫这三个为缓存，他们叫缓存，我们上面提到的 Memory Cache 等 cache 也叫缓存，不是很乱吗，而且浏览器把他们归到了 storage 里面，storage 翻译过来为存储。

还有一点，这里有五种：Cookies、Local Storage、Session Storage、WebSQL 和 IndexedDB。

我们知道垃圾回收机制是引擎来做的，JS 引擎有很多种（各个浏览器都不同），其垃圾回收机制在一些细节及优化上略有不同，本文我们以一些通用的回收算法作为切入，再由 V8 引擎发展至今对该机制的优化为例（为什么以 V8 为例？因为它市场占有率大 😄 ），一步一步深入来助我们了解垃圾回收机制，因为只有真正了解垃圾回收机制，后面才能理解内存泄漏的问题以及手动预防和优化
JavaScript 是门魅力无限的语言，关于它的 GC（垃圾回收）方面，你了解多少呢？想来大部分人是因为面试才去看一些面试题从而了解的垃圾回收，那在正式开始之前，给大家列几个小问题，大家可以先想一下答案，带着问题及答案再去看文章，最后读完此文如果你的答案可以优化，即有收获
什么是垃圾回收机制？
垃圾是怎样产生的？
为什么要进行垃圾回收？
垃圾回收是怎样进行的？
V8 引擎对垃圾回收进行了哪些优化？
当然，我们可不仅仅是为了面试，其目的是一次性彻底搞懂 GC！假如你对其中某块内容不太理解，不要着急，先读完整篇文章了解内容再回过头来仔细看一遍就会清晰很多，干货满满，先赞后看哦

为什么要进行垃圾回收

我们写代码的时候创建一个基本类型、对象、函数都是需要占用内存空间的，当我们不再需要这个东西的时候，如果不回收还是需要占用内存的话，内存会出现不够用的情况，这个就是我们有的时候出现的爆栈，严重导致程序崩溃

垃圾回收是这么进行的

垃圾回收的策略有两种，在不同的语言中有所不同

标记清除算法

介绍：目前 js 引擎最常用的就是标记清除法，只是在不同的浏览器中对此算法作出了一些优化
过程： 1.垃圾收集器会在运行时给内存中所有的变量都加上一个标记，假设标志内存中所有的变量都是垃圾，全标记为 0 2.然后从各个根对象开始遍历，把不是的垃圾的节点改成 1 3.清楚所有标志为 0 的垃圾，销毁并回收他们所用的内存空间 4.最后把所有的内存中的对象标志修改为 0，等待下一轮垃圾回收

优点：

优点就是比较简单，打标志就是两种状态打和不打

缺点：

1.标记清除是一个很大的缺点，就是清除之后，空出剩余的对象内存位置，这就导致出现很多的不连续的空间，也就是我们说的内存碎片碎片化

2.标记清除的话需要我们每隔一次遍历一次会阻塞 js 程序的执行，

引用计数算法

这种方式问题很多，所以现在我们用的很少了。他的策略是跟踪每个变量值被使用的次数

过程： 1.当一个值被赋值给一个变量，那么这个值的引用次数就为 1 2.如果同一个值又被赋值给另一个变量，那么引用数就加一 3.如果该变量的值被其他的值覆盖了，那这个值的引用次数就是减一 4.当该值的引用次数变成 0 的时候，说明没有变量在使用该值，这个时候垃圾回收器就会清除引用次数为 0 的值占用的内存。

优点
引用计数可以立即回收垃圾，标记清除的话需要我们每隔一次遍历一次会阻塞 js 程序的执行，

缺点
无法解决循环引用的问题，

V8 对 GC 的优化
上面我们总结了常见的 js 引擎的常见的垃圾回收机制，并且我们现在常用的是标记清除的方式，V8 引擎也是用的标记清除方式，并且他在此基础上面做了相应的优化

v8 优化的的核心就是实现分代式垃圾回收

分代式分为新生代和老生代
新生代:比较小，通常只有 1-8M，存放的存活时间较短的对象
老生代：从新生代中存活下来的对象，存活时间比较长

v8 采用两个垃圾回收器分别管控新老生代，他们各自又有自己的策略

新生代管理策略： 1.他首先会把新生代一分为二，分为使用区和空闲区， 2.新对象会先存放在使用区中，等使用区满了之后就会执行一次垃圾回收算法 3.开始垃圾回收算法：新生代回收器会对使用区的对象做标志，标记之后的对象复制到空闲区，把不再使用的对象空间清除掉，最后使用区和空闲区互换，多次来回（这样的复制过程其实也是对内存碎片的整理） 4.经过多次复制之后的对象没有依赖存活就会被放到老生代中进行管理，还有一种情况是一个对象占用的空间大于空闲区的 25%也会被直接放到老生代中

老生代管理策略：

不会分区复制来复制去，就是直接使用的标记清楚法，首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象，清除未标志的

并行回收
这里就会提到一个词叫全停顿，即：js 是单线程的的语言，垃圾回收会阻塞 js 脚本的执行。v8 为了解决在标记清楚的时候会阻塞 js 引擎的执行，所以他选择采用开启多个辅助线程的方式缩短干活的总时间，这样就阻塞的时间会大大减少

增标记和懒性清理量
由于对于一些比较大的对象来说，并行回收的依然会消耗很多的时间，2011 年之后 v8 的也不再使用并行回收的方式，采用增量标记方式，实现是通过三色标记法与写屏障

并发回收

三个都有对应的缺点，所以真实的 v8 垃圾回收都是通过多种方式融合来解决的

Session

session 是存储在服务器端的，也是一种记录服务端和客户端会话状态的机制
session 是基于 cookie 的，session 存储在客户端，sessionId 存储在
客户端的 cookie 中

session 的认证流程

1.用户第一次请求服务器的时候，服务端会生成 session 并把 sessionID 返回给客户端 2.客户端接收到 sessionID 会存储在 cookie 中， 3.等第二次请求的时候会携带上，服务端就是通过 sessionId 查找对应的 session 信息

css兼容性前缀

-webkit-     chrome
-o    Opera 苹果
-moz  火狐
-ms  IE


兼容性

通用的解决方案：
normalize.css  解决浏览器的css的默认样式
ios上面css3属性animation的无效

ios唤起输入弹窗之后不会弹回去

这个解决方式是监听失去焦点事件手动定位scrollTop

ios上面自动获取焦点不生效

ios上面输入框很难获取焦点，原因是fastclick.js

ios上下拉会出现空白 ，解决：阻止默认行为

ios软键盘弹起之后，fixed失效变成absolute

ios

安全性

cookie 存储在客户端，session 存储在服务端


ie11以上的兼容
使用垫片polyfill，


Cookie是服务器发送到用户浏览器并保存到本地的一小块数据，他会在浏览器下次向同一个服务器发起请求的时候被携带并发送到服务器上
Cookie常被用来作为数据的存储，但是他的设计目标是为了存储状态的，是为了识别两个请求是否来自同一个浏览器



Cookie的限制

1.大小的限制

cookie的大小限制一般不超过4kb，超出限制之后，会被浏览器自动清除掉，这个就是cookie为什么会被浏览器自动删除的原因。


2.域的限制
cookie不可以跨域读取，cookie是被哪个域写入的，只能被这个域或者是他的子域 ，比如就是test.com写入的test.com或者tj.test.com或者test.com/child读取，而不能被explame.com读取

3.路径的限制

4.时效限制
 

cookie的属性
举例访问的地址，下面的数据举例都在这个基础上：http://phc-chronic-h5-node-qa2.guahao-test.com/tianjin?stdOrgId=N81593471727
1.name/value

2.domain
指定可以访问该cookie的web战域  ，eg:guahao.test.com,表示只要是子域都可以访问到这个cookie

3.path

path标识指定了主机哪些路径可以接受Cookie

4.Expires

有效期，cookie分为会话性和持久性

设置为Session为持久性的


5.HTTPOnly
设置cookie能否通过js去访问，默认情况下面cookie不会带HTTPOnly这个配置，所以默认情况cookie可以通过js去访问（包括读取、修改、删除），如果设置了这个属性就是只能请求携带，不能通过js访问

在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，只能通过服务端去设置。

6.Secure
指定是否使用https的方式发送cookie



HTTP cookie 和document.cookie

document.cookie = `name=${name};expires=${expires}`
document.cookie一次只能写一个cookie，是新增不是覆盖



http协议是无状态的，cookie的出现使得能够记录稳定的信息，是服务端能够识别请求是否来自同一个浏览器


http为什么要携带cookie
http是无状态的，携带cookie能够让服务端识别来源是否是同一个浏览器，同时因为cookie的大小和体积比较小，携带不会对服务器压力造成很大的影响





cookie

他是由服务端通过在响应信息里面的额set-cookie发送到浏览器端，浏览器端保存在本地，在之后的每次请求中会带上这个cookie，我们也可以通过设置不携带cookie


cookie是不支持跨域的，只能在本域或者是子域中被访问到


cookie的大小限制

大小一般不超过4kb，也正是他的体积比较小才能在http请求中被携带

cookie的属性

name/value

domain

标识能够访问到cookie的站域

path

标识主机中哪些路径能够访问到cookie

Expires
过期时间，设置的是永久性和会话性


HTTPOnly

标识是否能通过js去访问，即：通过document.cookie
默认是没有这个标识的

Secure
是否通过https协议发送cookie


前端设置withCredential 为true

access-control-allow-origin


xss攻击：
概念：在代码中携带恶意代码就会造成xss攻击

分类
存储型攻击
就是在表单内容中插入恶意代码，但是没有做安全过滤，这样含有恶意代码的文本就会被存储到数据库中，这种危害很大，每个访问这条数据的页面都会被攻击
反射型攻击
在url地址上面携带了，比如携带的参数是<script></script>
DOM型攻击
他是纯前端的安全漏洞，因为恶意的代码的执行是要通过浏览器的

防御

基本就是在展示的时候进行信息过滤
转义，但是这种方式要谨慎使用，他可能因为使用的地方不用转义出现乱码情况
csp
HTTPOnly



CSRF攻击

cross-site   request  跨站请求伪造

攻击者诱导用户点击第三方的攻击网站，在攻击网站中向被攻击网站中发送跨站请求，利用受害者已经获取到了登录的凭证，就可以绕过后端的校验，认为是用户自己的请求，从而攻击者就可以进行某种操作


分类

get型csrf
img这种只是发送一个http请求


post的csrf
通常是使用空白的表单自动提交进行攻击


链接csrf
a标签这种，需要用户点击

预防

阻断不明外域的访问

同源检测

samesite cookie

提交时携带只有本域可以获取的信息

携带csrf token
双重cookie校验

攻击者向服务器提供恶意的SQL查询语句，程序执行了使用了sql语句，导致原始的查询逻辑被改变，


案例
页面的管理员登录的表单，
<form action="/login" method="POST">
    <p>Username: <input type="text" name="username" /></p>
    <p>Password: <input type="password" name="password" /></p>
    <p><input type="submit" value="登陆" /></p>
</form>
后端的sql语句如下

let querySQL = `
    SELECT *
    FROM user
    WHERE username='${username}'
    AND psw='${password}'
`;
当用户在界面输入的用户名是zoumiaojiang' OR 1 = 1 --，密码随意输入，管理员就可以登录账户
  
原因是

我们预想的sql语句
SELECT * FROM user WHERE username='zoumiaojiang' AND psw='mypassword'

恶意攻击之后的语句
SELECT * FROM user WHERE username='zoumiaojiang' OR 1 = 1 --' AND psw='xxxx'


--是注释后面的语句的意思，所以查询语句就变成，结果永远是真

SELECT * FROM user WHERE username='zoumiaojiang' OR 1 = 1

这就是一个SQL注入的案例

预防


就是我们不能相信用户输入的内容，尤其会影响我们的正常SQL语句的。对其要进行一些转义
常见的措施：

1.对输入到数据库的特殊字符进行转义；
2.对所有的查询语句建议使用数据库提供的参数化的查询接口，eg：占位符 ?
mysql.query(`SELECT * FROM user WHERE username = ? AND psw = ?`, [username, psw]);



点击劫持
概念


一个web页面隐藏了一个透明的iframe,用外层的假盒子诱导用户点击，实际上是在隐藏的iframe上面触发了点击进行了用于不知情的操作
流程
攻击者构建了一个非常有吸引力的网页【不知道哪些内容对你们来说有吸引力，我就不写页面了，偷个懒】
将被攻击的页面放置在当前页面的 iframe 中
使用样式将 iframe 叠加到非常有吸引力内容的上方
将iframe设置为透明 opacity：0
你被诱导点击了网页内容，你以为你点击的是***，而实际上，你成功被攻击了。


预防
X-Frame-Options,他是服务端可以设置的请求头，专门用来防御iframe的点击劫持的

取值三种，可以通过设置deny拒绝任何域的加载：

DENY: 拒绝任何域加载
SAMEORIGIN: 允许同源域下加载
ALLOW-FROM: 可以定义允许frame加载的页面地址



将多个计算机联合起来，对一个或者多个目标进行攻击，比如通过大量的合法的请求占用大量的网络资源，导致网络资源的瘫痪的目的等。

举个例子理解
一群恶霸试图让对面那家有着竞争关系的商铺无法正常营业，他们会采取什么手段呢？（只为举例，切勿模仿）
恶霸们扮作普通客户一直拥挤在对手的商铺，赖着不走，真正的购物者却无法进入；或者总是和营业员有一搭没一搭的东扯西扯，让工作人员不能正常服务客户；也可以为商铺的经营者提供虚假信息，商铺的上上下下忙成一团之后却发现都是一场空，最终跑了真正的大客户，损失惨重。
这种做法是伤敌一千自损八百的做法



集中处理样式

eg:
el.style.cssText="width:100px;height:100px;"
代替
el.style.width="100px"
el.style.height='200px'

循环操作多使用文档片段

createDocumentFragement  ，文档片段的操作不会引起多次重排

减少dom操作

eg：可以先隐藏元素display：none之后操作完成之后在改变为block

动画中改变大小和位置使用transform

will-change：transform
开启gpu加速页面渲染，较少cpu的压力






谈到HTTPS, 就不得不谈到与之相对的HTTP。HTTP的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，HTTP 数据经过 TCP 层，然后经过WIFI路由器、运营商和目标服务器，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的中间人攻击。
为了防范这样一类攻击，我们不得已要引入新的加密方案，即 HTTPS。
HTTPS并不是一个新的协议, 而是一个加强版的HTTP。其原理是在HTTP和TCP之间建立了一个中间层，当HTTP和TCP通信时并不是像以前那样直接通信，直接经过了一个中间层进行加密，将加密后的数据包传给TCP, 响应的，TCP必须将数据包解密，才能传给上面的HTTP。这个中间层也叫安全层。安全层的核心就是对数据加解密。
接下来我们就来剖析一下HTTPS的加解密是如何实现的。
对称加密和非对称加密
概念
首先需要理解对称加密和非对称加密的概念，然后讨论两者应用后的效果如何。
对称加密是最简单的方式，指的是加密和解密用的是同样的密钥。
而对于非对称加密，如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密。
加解密过程
接着我们来谈谈浏览器和服务器进行协商加解密的过程。
首先，浏览器会给服务器发送一个随机数client_random和一个加密的方法列表。
服务器接收后给浏览器返回另一个随机数server_random和加密方法。
现在，两者拥有三样相同的凭证: client_random、server_random和加密方法。
接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的暗号。
各自应用的效果
如果用对称加密的方式，那么第三方可以在中间获取到client_random、server_random和加密方法，由于这个加密方法同时可以解密，所以中间人可以成功对暗号进行解密，拿到数据，很容易就将这种加密方式破解了。
既然对称加密这么不堪一击，我们就来试一试非对称加密。在这种加密方式中，服务器手里有两把钥匙，一把是公钥，也就是说每个人都能拿到，是公开的，另一把是私钥，这把私钥只有服务器自己知道。
好，现在开始传输。
浏览器把client_random和加密方法列表传过来，服务器接收到，把server_random、加密方法和公钥传给浏览器。
现在两者拥有相同的client_random、server_random和加密方法。然后浏览器用公钥将client_random和server_random加密，生成与服务器通信的暗号。
这时候由于是非对称加密，公钥加密过的数据只能用私钥解密，因此中间人就算拿到浏览器传来的数据，由于他没有私钥，照样无法解密，保证了数据的安全性。
这难道一定就安全吗？聪明的小伙伴早就发现了端倪。回到非对称加密的定义，公钥加密的数据可以用私钥解密，那私钥加密的数据也可以用公钥解密呀！
服务器的数据只能用私钥进行加密(因为如果它用公钥那么浏览器也没法解密啦)，中间人一旦拿到公钥，那么就可以对服务端传来的数据进行解密了，就这样又被破解了。而且，只是采用非对称加密，对于服务器性能的消耗也是相当巨大的，因此我们暂且不采用这种方案。
对称加密和非对称加密的结合
可以发现，对称加密和非对称加密，单独应用任何一个，都会存在安全隐患。那我们能不能把两者结合，进一步保证安全呢？
其实是可以的，演示一下整个流程：

浏览器向服务器发送client_random和加密方法列表。
服务器接收到，返回server_random、加密方法以及公钥。
浏览器接收，接着生成另一个随机数pre_random, 并且用公钥加密，传给服务器。(敲黑板！重点操作！)
服务器用私钥解密这个被加密后的pre_random。

现在浏览器和服务器有三样相同的凭证:client_random、server_random和pre_random。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。
然后浏览器和服务器尽管用一样的密钥进行通信，即使用对称加密。
这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人没有私钥，从而拿不到pre_random，也就无法生成最终的密钥了。
回头比较一下和单纯的使用非对称加密, 这种方式做了什么改进呢？本质上是防止了私钥加密的数据外传。单独使用非对称加密，最大的漏洞在于服务器传数据给浏览器只能用私钥加密，这是危险产生的根源。利用对称和非对称加密结合的方式，就防止了这一点，从而保证了安全。
添加数字证书
尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。
事实上HTTPS在上述结合对称和非对称加密的基础上，又添加了数字证书认证的步骤。其目的就是让服务器证明自己的身份。

作者：神三元
链接：https://juejin.cn/post/6844904021308735502
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。




虚拟DOM的实现原理？

1.虚拟DOM本质上是js对象，是对真实dom的抽象
2.状态变更的时候，通过patch新旧节点，最小化更新到真实的dom上面
