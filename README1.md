then(onFulfilled, onRejected) {
// onFulfilled 如果不是函数，就忽略 onFulfilled，直接返回 value
onFulfilled =
typeof onFulfilled === "function" ? onFulfilled : (value) => value;
onRejected =
typeof onRejected === "function"
? onRejected
: (err) => {
throw err;
};
// 实现链式调用所以需要返回的是一个 promise
let promise2 = new myPromise((resolve, reject) => {
if (this.status === statusOptions["FULFILLED"]) {
// promiseA+规范规定 onFulfilled, onRejected 不能是同步的;
setTimeout(() => {
try {
const x = onFulfilled(this.result); //执行函数，传出去终值
resolvePromise(promise2, x, resolve, reject); //处理 x 的不同值 ,为了将这个 promise2 返回的值传递到下一个 then 中
} catch (error) {
reject(error);
}
}, 0);
} else if (this.status === statusOptions["REJECTED"]) {
setTimeout(() => {
try {
const x = onRejected(this.result); //执行函数，传出去终值
resolvePromise(promise2, x, resolve, reject);
} catch (error) {
reject(error);
}
}, 0);
} else if (this.status === statusOptions["PENDING"]) {
// 实现异步
this.onFulfilledCallbacks.push(() => {
setTimeout(() => {
try {
const x = onFulfilled(this.result); //执行函数，传出去终值
resolvePromise(promise2, x, resolve, reject);
} catch (error) {
reject(error);
}
}, 0);
});
this.onRejectedCallbacks.push(() => {
setTimeout(() => {
try {
const x = onRejected(this.result); //执行函数，传出去终值
resolvePromise(promise2, x, resolve, reject); //处理 x 的不同值
} catch (error) {
reject(error);
}
}, 0);
});
}
});
return promise2;
}

3.1 标记清除

这是 javascript 中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。
当对象，无法从根对象沿着引用遍历到，即不可达（unreachable），进行清除。对于上面的例子，fn() 里面的 a 和 b 在函数执行完毕后，就不能通过外面的上下文进行访问了，所以就可以清除了。
这是当前主流的 GC 算法，V8 里面就是用这种。
不管是高级语言，还是低级语言。内存的管理都是：分配内存使用内存（读或写）释放内存前两步，大家都没有太大异议。关键是释放内存这一步，各种语言都有自己的垃圾回收（garbage collection, 简称 GC）机制。

在大部分的应用场景：一个新创建的对象，生命周期通常很短。所以，V8 里面，GC 处理分为两大类：新生代和老生代。
新生代的堆空间为 1M~8M，而且被平分成两份（to-space 和 from-space），通常一个新创建的对象，内存被分配在新生代。当 to-space 满的时候，to-space 和 form-space 交换位置（此时，to 空，from 满），并执行 GC。如果一个对象被断定为，未被引用，就清除；有被引用，逃逸次数+1（如果此时逃逸次数为 2，就移入老生代，否则移入 to-space）。
老生代的堆空间大，GC 不适合像新生代那样，用平分成两个 space 这种空间换时间的方式。老生代的垃圾回收，分两个阶段：标记、清理（有 Sweeping 和 Compacting 这两种方式）。
标记，采用 3 色标记：黑、白、灰。步骤如下：
GC 开始，所以对象标记为白色。
根对象标记为黑色，并开始遍历其子节点（引用的对象）。
当前被遍历的节点，标记为灰色，被放入一个叫 marking bitmap 的栈。在栈中，把当前被遍历的节点，标记为黑色，并出栈，同时，把它的子节点（如果有的话）标记为灰色，并压入栈。（大对象比较特殊，这里不展开）
当所有对象被遍历完后，就只剩下黑和白。通过 Sweeping 或 Compacting 的方式，清理掉白色，完成 GC。
3.2 引用计次
引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1。当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。
但是用这种方法存在着一个问题，下面来看看代码：
function problem() {
var objA = new Object();
var objB = new Object();

    objA.someOtherObject = objB;
    objB.anotherObject = objA;

}

在这个例子中，objA 和 objB 通过各自的属性相互引用；也就是说这两个对象的引用次数都是 2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA 和 objB 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。
大多数浏览器已经放弃了这种回收方式。

4. 浏览器的本地存储
   如果我问你，浏览器中的缓存有哪些，我相信绝大部分人会说有三种：cookie，sessionStorage，localStorage。
   但是诶，我不知为什么大家都叫这三个为缓存，他们叫缓存，我们上面提到的 Memory Cache 等 cache 也叫缓存，不是很乱吗，而且浏览器把他们归到了 storage 里面，storage 翻译过来为存储。

还有一点，这里有五种：Cookies、Local Storage、Session Storage、WebSQL 和 IndexedDB。

我们知道垃圾回收机制是引擎来做的，JS 引擎有很多种（各个浏览器都不同），其垃圾回收机制在一些细节及优化上略有不同，本文我们以一些通用的回收算法作为切入，再由 V8 引擎发展至今对该机制的优化为例（为什么以 V8 为例？因为它市场占有率大 😄 ），一步一步深入来助我们了解垃圾回收机制，因为只有真正了解垃圾回收机制，后面才能理解内存泄漏的问题以及手动预防和优化
JavaScript 是门魅力无限的语言，关于它的 GC（垃圾回收）方面，你了解多少呢？想来大部分人是因为面试才去看一些面试题从而了解的垃圾回收，那在正式开始之前，给大家列几个小问题，大家可以先想一下答案，带着问题及答案再去看文章，最后读完此文如果你的答案可以优化，即有收获
什么是垃圾回收机制？
垃圾是怎样产生的？
为什么要进行垃圾回收？
垃圾回收是怎样进行的？
V8 引擎对垃圾回收进行了哪些优化？
当然，我们可不仅仅是为了面试，其目的是一次性彻底搞懂 GC！假如你对其中某块内容不太理解，不要着急，先读完整篇文章了解内容再回过头来仔细看一遍就会清晰很多，干货满满，先赞后看哦

为什么要进行垃圾回收

我们写代码的时候创建一个基本类型、对象、函数都是需要占用内存空间的，当我们不再需要这个东西的时候，如果不回收还是需要占用内存的话，内存会出现不够用的情况，这个就是我们有的时候出现的爆栈，严重导致程序崩溃

垃圾回收是这么进行的

垃圾回收的策略有两种，在不同的语言中有所不同

标记清除算法

介绍：目前 js 引擎最常用的就是标记清除法，只是在不同的浏览器中对此算法作出了一些优化
过程： 1.垃圾收集器会在运行时给内存中所有的变量都加上一个标记，假设标志内存中所有的变量都是垃圾，全标记为 0 2.然后从各个根对象开始遍历，把不是的垃圾的节点改成 1 3.清楚所有标志为 0 的垃圾，销毁并回收他们所用的内存空间 4.最后把所有的内存中的对象标志修改为 0，等待下一轮垃圾回收

优点：

优点就是比较简单，打标志就是两种状态打和不打

缺点：

1.标记清除是一个很大的缺点，就是清除之后，空出剩余的对象内存位置，这就导致出现很多的不连续的空间，也就是我们说的内存碎片碎片化

2.标记清除的话需要我们每隔一次遍历一次会阻塞 js 程序的执行，

引用计数算法

这种方式问题很多，所以现在我们用的很少了。他的策略是跟踪每个变量值被使用的次数

过程： 1.当一个值被赋值给一个变量，那么这个值的引用次数就为 1 2.如果同一个值又被赋值给另一个变量，那么引用数就加一 3.如果该变量的值被其他的值覆盖了，那这个值的引用次数就是减一 4.当该值的引用次数变成 0 的时候，说明没有变量在使用该值，这个时候垃圾回收器就会清除引用次数为 0 的值占用的内存。

优点
引用计数可以立即回收垃圾，标记清除的话需要我们每隔一次遍历一次会阻塞 js 程序的执行，

缺点
无法解决循环引用的问题，

V8 对 GC 的优化
上面我们总结了常见的 js 引擎的常见的垃圾回收机制，并且我们现在常用的是标记清除的方式，V8 引擎也是用的标记清除方式，并且他在此基础上面做了相应的优化

v8 优化的的核心就是实现分代式垃圾回收

分代式分为新生代和老生代
新生代:比较小，通常只有 1-8M，存放的存活时间较短的对象
老生代：从新生代中存活下来的对象，存活时间比较长

v8 采用两个垃圾回收器分别管控新老生代，他们各自又有自己的策略

新生代管理策略： 1.他首先会把新生代一分为二，分为使用区和空闲区， 2.新对象会先存放在使用区中，等使用区满了之后就会执行一次垃圾回收算法 3.开始垃圾回收算法：新生代回收器会对使用区的对象做标志，标记之后的对象复制到空闲区，把不再使用的对象空间清除掉，最后使用区和空闲区互换，多次来回（这样的复制过程其实也是对内存碎片的整理） 4.经过多次复制之后的对象没有依赖存活就会被放到老生代中进行管理，还有一种情况是一个对象占用的空间大于空闲区的 25%也会被直接放到老生代中

老生代管理策略：

不会分区复制来复制去，就是直接使用的标记清楚法，首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象，清除未标志的

并行回收
这里就会提到一个词叫全停顿，即：js 是单线程的的语言，垃圾回收会阻塞 js 脚本的执行。v8 为了解决在标记清楚的时候会阻塞 js 引擎的执行，所以他选择采用开启多个辅助线程的方式缩短干活的总时间，这样就阻塞的时间会大大减少

增标记和懒性清理量
由于对于一些比较大的对象来说，并行回收的依然会消耗很多的时间，2011 年之后 v8 的也不再使用并行回收的方式，采用增量标记方式，实现是通过三色标记法与写屏障

并发回收

三个都有对应的缺点，所以真实的 v8 垃圾回收都是通过多种方式融合来解决的

Session

session 是存储在服务器端的，也是一种记录服务端和客户端会话状态的机制
session 是基于 cookie 的，session 存储在客户端，sessionId 存储在
客户端的 cookie 中

session 的认证流程

1.用户第一次请求服务器的时候，服务端会生成 session 并把 sessionID 返回给客户端 2.客户端接收到 sessionID 会存储在 cookie 中， 3.等第二次请求的时候会携带上，服务端就是通过 sessionId 查找对应的 session 信息

Cookie 和 Session 的区别

安全性

cookie 存储在客户端，session 存储在服务端

有效期
cookie 存储的时间可以自己设置，session 存储的时间比较短，客户端关闭一般都会失效
存储大小

cookie 存储容量比较小，不超过 4kb，session 存储的容量比较大

cookie 只能存储字符串，或者要转换为字符串才能存储
